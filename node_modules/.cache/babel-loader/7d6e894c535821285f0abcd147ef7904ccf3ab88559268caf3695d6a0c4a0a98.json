{"ast":null,"code":"// Utility functions for data storage and retrieval\n\nexport const saveToLocalStorage = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n    return true;\n  } catch (error) {\n    console.error('Error saving to localStorage:', error);\n    return false;\n  }\n};\nexport const loadFromLocalStorage = (key, defaultValue = null) => {\n  try {\n    const item = localStorage.getItem(key);\n    return item ? JSON.parse(item) : defaultValue;\n  } catch (error) {\n    console.error('Error loading from localStorage:', error);\n    return defaultValue;\n  }\n};\n\n// Data migration function for categories\nexport const migrateCategories = () => {\n  const existingCategories = loadFromLocalStorage('categories');\n  if (!existingCategories || existingCategories.length === 0) {\n    // Create default categories if none exist\n    const defaultCategories = [{\n      id: 1,\n      name: 'Sub Junior',\n      order: 1\n    }, {\n      id: 2,\n      name: 'Junior',\n      order: 2\n    }, {\n      id: 3,\n      name: 'Senior',\n      order: 3\n    }];\n    saveToLocalStorage('categories', defaultCategories);\n    return defaultCategories;\n  }\n  return existingCategories;\n};\n\n// Calculate team standings based on results\nexport const calculateTeamStandings = (teams, results, pointsConfig, categoryPointsConfig = {}, gradePointsConfig = {}) => {\n  // Initialize medal counts for each team\n  const teamStandings = teams.map(team => ({\n    ...team,\n    gold: 0,\n    silver: 0,\n    bronze: 0,\n    totalPoints: 0\n  }));\n\n  // Process results to count medals and points\n  results.forEach(result => {\n    result.participants.forEach(participant => {\n      // Find the student to get their team\n      const students = loadFromLocalStorage('students', []);\n      const student = students.find(s => s.chestNumber === participant.name || s.name === participant.name);\n      if (student) {\n        // Find the team in standings\n        const teamIndex = teamStandings.findIndex(t => t.name === student.team);\n        if (teamIndex !== -1) {\n          // Extract grade from participant name if it exists\n          let grade = '';\n          let participantName = participant.name;\n\n          // Updated regex to handle more grades (A, B, C, D)\n          const gradeMatch = participant.name.match(/\\(([A-D])\\)$/);\n          if (gradeMatch) {\n            grade = gradeMatch[1];\n            participantName = participant.name.replace(/\\s*\\([A-D]\\)$/, '');\n          }\n\n          // Use grade-specific points if available\n          let categoryPointConfig = pointsConfig; // default\n\n          if (grade && result.category) {\n            const gradeKey = `${result.category}-${grade}`;\n            if (gradePointsConfig[gradeKey]) {\n              categoryPointConfig = gradePointsConfig[gradeKey];\n            } else if (categoryPointsConfig[result.category]) {\n              // Fall back to category-specific points\n              categoryPointConfig = categoryPointsConfig[result.category];\n            }\n          } else if (categoryPointsConfig[result.category]) {\n            // Use category-specific points if no grade specified\n            categoryPointConfig = categoryPointsConfig[result.category];\n          }\n\n          // Increment medal count based on position\n          switch (participant.position.toLowerCase()) {\n            case '1':\n            case 'first':\n            case 'gold':\n              teamStandings[teamIndex].gold += 1;\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.gold || pointsConfig.gold || 3;\n              break;\n            case '2':\n            case 'second':\n            case 'silver':\n              teamStandings[teamIndex].silver += 1;\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.silver || pointsConfig.silver || 2;\n              break;\n            case '3':\n            case 'third':\n            case 'bronze':\n              teamStandings[teamIndex].bronze += 1;\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.bronze || pointsConfig.bronze || 1;\n              break;\n          }\n        }\n      }\n    });\n  });\n\n  // Sort teams by total points (descending)\n  teamStandings.sort((a, b) => b.totalPoints - a.totalPoints);\n\n  // Add rank to each team\n  teamStandings.forEach((team, index) => {\n    team.rank = index + 1;\n  });\n  return teamStandings;\n};\n\n// Calculate top performers based on points\nexport const calculateTopPerformers = results => {\n  const performerPoints = {};\n\n  // Aggregate points for each performer\n  results.forEach(result => {\n    result.participants.forEach(participant => {\n      if (!performerPoints[participant.name]) {\n        performerPoints[participant.name] = {\n          name: participant.name,\n          totalPoints: 0,\n          programs: []\n        };\n      }\n      performerPoints[participant.name].totalPoints += participant.points || 0;\n      performerPoints[participant.name].programs.push({\n        program: result.program,\n        position: participant.position,\n        points: participant.points || 0\n      });\n    });\n  });\n\n  // Convert to array and sort by points\n  const performers = Object.values(performerPoints);\n  performers.sort((a, b) => b.totalPoints - a.totalPoints);\n\n  // Format for display (top 10)\n  return performers.slice(0, 10).map((performer, index) => {\n    var _performer$programs$;\n    return {\n      id: index + 1,\n      name: performer.name,\n      program: ((_performer$programs$ = performer.programs[0]) === null || _performer$programs$ === void 0 ? void 0 : _performer$programs$.program) || 'Various',\n      points: performer.totalPoints\n    };\n  });\n};\n\n// Initialize default data if not present\nexport const initializeDefaultData = () => {\n  // Check if we have initialized data already\n  const isInitialized = loadFromLocalStorage('initialized', false);\n  if (!isInitialized) {\n    // Initialize categories\n    migrateCategories();\n\n    // Initialize other default data\n    const defaultEvents = [{\n      id: 1,\n      name: 'Dance Competition',\n      categories: ['Sub Junior', 'Junior', 'Senior'],\n      color: {\n        r: 106,\n        g: 17,\n        b: 203\n      }\n    }];\n    const defaultTeams = [{\n      id: 1,\n      name: 'Team Alpha',\n      color: '#FF5733'\n    }];\n    const defaultPrograms = [{\n      id: 1,\n      name: 'Classical Dance',\n      type: 'Individual'\n    }];\n    const defaultPoints = {\n      gold: 3,\n      silver: 2,\n      bronze: 1\n    };\n\n    // Set default admin password\n    const defaultAdminPassword = 'admin123';\n\n    // Initialize empty team managers array\n    const defaultTeamManagers = [];\n    saveToLocalStorage('events', defaultEvents);\n    saveToLocalStorage('teams', defaultTeams);\n    saveToLocalStorage('programs', defaultPrograms);\n    saveToLocalStorage('points', defaultPoints);\n    saveToLocalStorage('adminPassword', defaultAdminPassword);\n    saveToLocalStorage('categoryPoints', {}); // Initialize empty category points\n    saveToLocalStorage('gradePoints', {}); // Initialize empty grade points\n    saveToLocalStorage('teamManagers', defaultTeamManagers); // Initialize empty team managers\n    saveToLocalStorage('availableGrades', ['A', 'B', 'C', 'D']);\n    saveToLocalStorage('initialized', true);\n  }\n};","map":{"version":3,"names":["saveToLocalStorage","key","data","localStorage","setItem","JSON","stringify","error","console","loadFromLocalStorage","defaultValue","item","getItem","parse","migrateCategories","existingCategories","length","defaultCategories","id","name","order","calculateTeamStandings","teams","results","pointsConfig","categoryPointsConfig","gradePointsConfig","teamStandings","map","team","gold","silver","bronze","totalPoints","forEach","result","participants","participant","students","student","find","s","chestNumber","teamIndex","findIndex","t","grade","participantName","gradeMatch","match","replace","categoryPointConfig","category","gradeKey","position","toLowerCase","sort","a","b","index","rank","calculateTopPerformers","performerPoints","programs","points","push","program","performers","Object","values","slice","performer","_performer$programs$","initializeDefaultData","isInitialized","defaultEvents","categories","color","r","g","defaultTeams","defaultPrograms","type","defaultPoints","defaultAdminPassword","defaultTeamManagers"],"sources":["C:/Users/SMIC_STUDIO/Desktop/MEHFIL 25 APP/src/utils/dataStorage.js"],"sourcesContent":["// Utility functions for data storage and retrieval\r\n\r\nexport const saveToLocalStorage = (key, data) => {\r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(data));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving to localStorage:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const loadFromLocalStorage = (key, defaultValue = null) => {\r\n  try {\r\n    const item = localStorage.getItem(key);\r\n    return item ? JSON.parse(item) : defaultValue;\r\n  } catch (error) {\r\n    console.error('Error loading from localStorage:', error);\r\n    return defaultValue;\r\n  }\r\n};\r\n\r\n// Data migration function for categories\r\nexport const migrateCategories = () => {\r\n  const existingCategories = loadFromLocalStorage('categories');\r\n  \r\n  if (!existingCategories || existingCategories.length === 0) {\r\n    // Create default categories if none exist\r\n    const defaultCategories = [\r\n      { id: 1, name: 'Sub Junior', order: 1 },\r\n      { id: 2, name: 'Junior', order: 2 },\r\n      { id: 3, name: 'Senior', order: 3 }\r\n    ];\r\n    \r\n    saveToLocalStorage('categories', defaultCategories);\r\n    return defaultCategories;\r\n  }\r\n  \r\n  return existingCategories;\r\n};\r\n\r\n// Calculate team standings based on results\r\nexport const calculateTeamStandings = (teams, results, pointsConfig, categoryPointsConfig = {}, gradePointsConfig = {}) => {\r\n  // Initialize medal counts for each team\r\n  const teamStandings = teams.map(team => ({\r\n    ...team,\r\n    gold: 0,\r\n    silver: 0,\r\n    bronze: 0,\r\n    totalPoints: 0\r\n  }));\r\n  \r\n  // Process results to count medals and points\r\n  results.forEach(result => {\r\n    result.participants.forEach(participant => {\r\n      // Find the student to get their team\r\n      const students = loadFromLocalStorage('students', []);\r\n      const student = students.find(s => \r\n        s.chestNumber === participant.name || \r\n        s.name === participant.name\r\n      );\r\n      \r\n      if (student) {\r\n        // Find the team in standings\r\n        const teamIndex = teamStandings.findIndex(t => t.name === student.team);\r\n        if (teamIndex !== -1) {\r\n          // Extract grade from participant name if it exists\r\n          let grade = '';\r\n          let participantName = participant.name;\r\n          \r\n          // Updated regex to handle more grades (A, B, C, D)\r\n          const gradeMatch = participant.name.match(/\\(([A-D])\\)$/);\r\n          if (gradeMatch) {\r\n            grade = gradeMatch[1];\r\n            participantName = participant.name.replace(/\\s*\\([A-D]\\)$/, '');\r\n          }\r\n          \r\n          // Use grade-specific points if available\r\n          let categoryPointConfig = pointsConfig; // default\r\n          \r\n          if (grade && result.category) {\r\n            const gradeKey = `${result.category}-${grade}`;\r\n            if (gradePointsConfig[gradeKey]) {\r\n              categoryPointConfig = gradePointsConfig[gradeKey];\r\n            } else if (categoryPointsConfig[result.category]) {\r\n              // Fall back to category-specific points\r\n              categoryPointConfig = categoryPointsConfig[result.category];\r\n            }\r\n          } else if (categoryPointsConfig[result.category]) {\r\n            // Use category-specific points if no grade specified\r\n            categoryPointConfig = categoryPointsConfig[result.category];\r\n          }\r\n          \r\n          // Increment medal count based on position\r\n          switch (participant.position.toLowerCase()) {\r\n            case '1':\r\n            case 'first':\r\n            case 'gold':\r\n              teamStandings[teamIndex].gold += 1;\r\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.gold || pointsConfig.gold || 3;\r\n              break;\r\n            case '2':\r\n            case 'second':\r\n            case 'silver':\r\n              teamStandings[teamIndex].silver += 1;\r\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.silver || pointsConfig.silver || 2;\r\n              break;\r\n            case '3':\r\n            case 'third':\r\n            case 'bronze':\r\n              teamStandings[teamIndex].bronze += 1;\r\n              teamStandings[teamIndex].totalPoints += categoryPointConfig.bronze || pointsConfig.bronze || 1;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  // Sort teams by total points (descending)\r\n  teamStandings.sort((a, b) => b.totalPoints - a.totalPoints);\r\n  \r\n  // Add rank to each team\r\n  teamStandings.forEach((team, index) => {\r\n    team.rank = index + 1;\r\n  });\r\n  \r\n  return teamStandings;\r\n};\r\n\r\n// Calculate top performers based on points\r\nexport const calculateTopPerformers = (results) => {\r\n  const performerPoints = {};\r\n  \r\n  // Aggregate points for each performer\r\n  results.forEach(result => {\r\n    result.participants.forEach(participant => {\r\n      if (!performerPoints[participant.name]) {\r\n        performerPoints[participant.name] = {\r\n          name: participant.name,\r\n          totalPoints: 0,\r\n          programs: []\r\n        };\r\n      }\r\n      \r\n      performerPoints[participant.name].totalPoints += participant.points || 0;\r\n      performerPoints[participant.name].programs.push({\r\n        program: result.program,\r\n        position: participant.position,\r\n        points: participant.points || 0\r\n      });\r\n    });\r\n  });\r\n  \r\n  // Convert to array and sort by points\r\n  const performers = Object.values(performerPoints);\r\n  performers.sort((a, b) => b.totalPoints - a.totalPoints);\r\n  \r\n  // Format for display (top 10)\r\n  return performers.slice(0, 10).map((performer, index) => ({\r\n    id: index + 1,\r\n    name: performer.name,\r\n    program: performer.programs[0]?.program || 'Various',\r\n    points: performer.totalPoints\r\n  }));\r\n};\r\n\r\n// Initialize default data if not present\r\nexport const initializeDefaultData = () => {\r\n  // Check if we have initialized data already\r\n  const isInitialized = loadFromLocalStorage('initialized', false);\r\n  \r\n  if (!isInitialized) {\r\n    // Initialize categories\r\n    migrateCategories();\r\n    \r\n    // Initialize other default data\r\n    const defaultEvents = [\r\n      { id: 1, name: 'Dance Competition', categories: ['Sub Junior', 'Junior', 'Senior'], color: { r: 106, g: 17, b: 203 } }\r\n    ];\r\n    \r\n    const defaultTeams = [\r\n      { id: 1, name: 'Team Alpha', color: '#FF5733' }\r\n    ];\r\n    \r\n    const defaultPrograms = [\r\n      { id: 1, name: 'Classical Dance', type: 'Individual' }\r\n    ];\r\n    \r\n    const defaultPoints = {\r\n      gold: 3,\r\n      silver: 2,\r\n      bronze: 1\r\n    };\r\n    \r\n    // Set default admin password\r\n    const defaultAdminPassword = 'admin123';\r\n    \r\n    // Initialize empty team managers array\r\n    const defaultTeamManagers = [];\r\n    \r\n    saveToLocalStorage('events', defaultEvents);\r\n    saveToLocalStorage('teams', defaultTeams);\r\n    saveToLocalStorage('programs', defaultPrograms);\r\n    saveToLocalStorage('points', defaultPoints);\r\n    saveToLocalStorage('adminPassword', defaultAdminPassword);\r\n    saveToLocalStorage('categoryPoints', {}); // Initialize empty category points\r\n    saveToLocalStorage('gradePoints', {}); // Initialize empty grade points\r\n    saveToLocalStorage('teamManagers', defaultTeamManagers); // Initialize empty team managers\r\n    saveToLocalStorage('availableGrades', ['A', 'B', 'C', 'D']);\r\n    saveToLocalStorage('initialized', true);\r\n  }\r\n};\r\n"],"mappings":"AAAA;;AAEA,OAAO,MAAMA,kBAAkB,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;EAC/C,IAAI;IACFC,YAAY,CAACC,OAAO,CAACH,GAAG,EAAEI,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC,CAAC;IAC/C,OAAO,IAAI;EACb,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACrD,OAAO,KAAK;EACd;AACF,CAAC;AAED,OAAO,MAAME,oBAAoB,GAAGA,CAACR,GAAG,EAAES,YAAY,GAAG,IAAI,KAAK;EAChE,IAAI;IACF,MAAMC,IAAI,GAAGR,YAAY,CAACS,OAAO,CAACX,GAAG,CAAC;IACtC,OAAOU,IAAI,GAAGN,IAAI,CAACQ,KAAK,CAACF,IAAI,CAAC,GAAGD,YAAY;EAC/C,CAAC,CAAC,OAAOH,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IACxD,OAAOG,YAAY;EACrB;AACF,CAAC;;AAED;AACA,OAAO,MAAMI,iBAAiB,GAAGA,CAAA,KAAM;EACrC,MAAMC,kBAAkB,GAAGN,oBAAoB,CAAC,YAAY,CAAC;EAE7D,IAAI,CAACM,kBAAkB,IAAIA,kBAAkB,CAACC,MAAM,KAAK,CAAC,EAAE;IAC1D;IACA,MAAMC,iBAAiB,GAAG,CACxB;MAAEC,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,YAAY;MAAEC,KAAK,EAAE;IAAE,CAAC,EACvC;MAAEF,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAE;IAAE,CAAC,EACnC;MAAEF,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAE;IAAE,CAAC,CACpC;IAEDpB,kBAAkB,CAAC,YAAY,EAAEiB,iBAAiB,CAAC;IACnD,OAAOA,iBAAiB;EAC1B;EAEA,OAAOF,kBAAkB;AAC3B,CAAC;;AAED;AACA,OAAO,MAAMM,sBAAsB,GAAGA,CAACC,KAAK,EAAEC,OAAO,EAAEC,YAAY,EAAEC,oBAAoB,GAAG,CAAC,CAAC,EAAEC,iBAAiB,GAAG,CAAC,CAAC,KAAK;EACzH;EACA,MAAMC,aAAa,GAAGL,KAAK,CAACM,GAAG,CAACC,IAAI,KAAK;IACvC,GAAGA,IAAI;IACPC,IAAI,EAAE,CAAC;IACPC,MAAM,EAAE,CAAC;IACTC,MAAM,EAAE,CAAC;IACTC,WAAW,EAAE;EACf,CAAC,CAAC,CAAC;;EAEH;EACAV,OAAO,CAACW,OAAO,CAACC,MAAM,IAAI;IACxBA,MAAM,CAACC,YAAY,CAACF,OAAO,CAACG,WAAW,IAAI;MACzC;MACA,MAAMC,QAAQ,GAAG7B,oBAAoB,CAAC,UAAU,EAAE,EAAE,CAAC;MACrD,MAAM8B,OAAO,GAAGD,QAAQ,CAACE,IAAI,CAACC,CAAC,IAC7BA,CAAC,CAACC,WAAW,KAAKL,WAAW,CAAClB,IAAI,IAClCsB,CAAC,CAACtB,IAAI,KAAKkB,WAAW,CAAClB,IACzB,CAAC;MAED,IAAIoB,OAAO,EAAE;QACX;QACA,MAAMI,SAAS,GAAGhB,aAAa,CAACiB,SAAS,CAACC,CAAC,IAAIA,CAAC,CAAC1B,IAAI,KAAKoB,OAAO,CAACV,IAAI,CAAC;QACvE,IAAIc,SAAS,KAAK,CAAC,CAAC,EAAE;UACpB;UACA,IAAIG,KAAK,GAAG,EAAE;UACd,IAAIC,eAAe,GAAGV,WAAW,CAAClB,IAAI;;UAEtC;UACA,MAAM6B,UAAU,GAAGX,WAAW,CAAClB,IAAI,CAAC8B,KAAK,CAAC,cAAc,CAAC;UACzD,IAAID,UAAU,EAAE;YACdF,KAAK,GAAGE,UAAU,CAAC,CAAC,CAAC;YACrBD,eAAe,GAAGV,WAAW,CAAClB,IAAI,CAAC+B,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;UACjE;;UAEA;UACA,IAAIC,mBAAmB,GAAG3B,YAAY,CAAC,CAAC;;UAExC,IAAIsB,KAAK,IAAIX,MAAM,CAACiB,QAAQ,EAAE;YAC5B,MAAMC,QAAQ,GAAG,GAAGlB,MAAM,CAACiB,QAAQ,IAAIN,KAAK,EAAE;YAC9C,IAAIpB,iBAAiB,CAAC2B,QAAQ,CAAC,EAAE;cAC/BF,mBAAmB,GAAGzB,iBAAiB,CAAC2B,QAAQ,CAAC;YACnD,CAAC,MAAM,IAAI5B,oBAAoB,CAACU,MAAM,CAACiB,QAAQ,CAAC,EAAE;cAChD;cACAD,mBAAmB,GAAG1B,oBAAoB,CAACU,MAAM,CAACiB,QAAQ,CAAC;YAC7D;UACF,CAAC,MAAM,IAAI3B,oBAAoB,CAACU,MAAM,CAACiB,QAAQ,CAAC,EAAE;YAChD;YACAD,mBAAmB,GAAG1B,oBAAoB,CAACU,MAAM,CAACiB,QAAQ,CAAC;UAC7D;;UAEA;UACA,QAAQf,WAAW,CAACiB,QAAQ,CAACC,WAAW,CAAC,CAAC;YACxC,KAAK,GAAG;YACR,KAAK,OAAO;YACZ,KAAK,MAAM;cACT5B,aAAa,CAACgB,SAAS,CAAC,CAACb,IAAI,IAAI,CAAC;cAClCH,aAAa,CAACgB,SAAS,CAAC,CAACV,WAAW,IAAIkB,mBAAmB,CAACrB,IAAI,IAAIN,YAAY,CAACM,IAAI,IAAI,CAAC;cAC1F;YACF,KAAK,GAAG;YACR,KAAK,QAAQ;YACb,KAAK,QAAQ;cACXH,aAAa,CAACgB,SAAS,CAAC,CAACZ,MAAM,IAAI,CAAC;cACpCJ,aAAa,CAACgB,SAAS,CAAC,CAACV,WAAW,IAAIkB,mBAAmB,CAACpB,MAAM,IAAIP,YAAY,CAACO,MAAM,IAAI,CAAC;cAC9F;YACF,KAAK,GAAG;YACR,KAAK,OAAO;YACZ,KAAK,QAAQ;cACXJ,aAAa,CAACgB,SAAS,CAAC,CAACX,MAAM,IAAI,CAAC;cACpCL,aAAa,CAACgB,SAAS,CAAC,CAACV,WAAW,IAAIkB,mBAAmB,CAACnB,MAAM,IAAIR,YAAY,CAACQ,MAAM,IAAI,CAAC;cAC9F;UACJ;QACF;MACF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACAL,aAAa,CAAC6B,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACzB,WAAW,GAAGwB,CAAC,CAACxB,WAAW,CAAC;;EAE3D;EACAN,aAAa,CAACO,OAAO,CAAC,CAACL,IAAI,EAAE8B,KAAK,KAAK;IACrC9B,IAAI,CAAC+B,IAAI,GAAGD,KAAK,GAAG,CAAC;EACvB,CAAC,CAAC;EAEF,OAAOhC,aAAa;AACtB,CAAC;;AAED;AACA,OAAO,MAAMkC,sBAAsB,GAAItC,OAAO,IAAK;EACjD,MAAMuC,eAAe,GAAG,CAAC,CAAC;;EAE1B;EACAvC,OAAO,CAACW,OAAO,CAACC,MAAM,IAAI;IACxBA,MAAM,CAACC,YAAY,CAACF,OAAO,CAACG,WAAW,IAAI;MACzC,IAAI,CAACyB,eAAe,CAACzB,WAAW,CAAClB,IAAI,CAAC,EAAE;QACtC2C,eAAe,CAACzB,WAAW,CAAClB,IAAI,CAAC,GAAG;UAClCA,IAAI,EAAEkB,WAAW,CAAClB,IAAI;UACtBc,WAAW,EAAE,CAAC;UACd8B,QAAQ,EAAE;QACZ,CAAC;MACH;MAEAD,eAAe,CAACzB,WAAW,CAAClB,IAAI,CAAC,CAACc,WAAW,IAAII,WAAW,CAAC2B,MAAM,IAAI,CAAC;MACxEF,eAAe,CAACzB,WAAW,CAAClB,IAAI,CAAC,CAAC4C,QAAQ,CAACE,IAAI,CAAC;QAC9CC,OAAO,EAAE/B,MAAM,CAAC+B,OAAO;QACvBZ,QAAQ,EAAEjB,WAAW,CAACiB,QAAQ;QAC9BU,MAAM,EAAE3B,WAAW,CAAC2B,MAAM,IAAI;MAChC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,MAAMG,UAAU,GAAGC,MAAM,CAACC,MAAM,CAACP,eAAe,CAAC;EACjDK,UAAU,CAACX,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACzB,WAAW,GAAGwB,CAAC,CAACxB,WAAW,CAAC;;EAExD;EACA,OAAOkC,UAAU,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC1C,GAAG,CAAC,CAAC2C,SAAS,EAAEZ,KAAK;IAAA,IAAAa,oBAAA;IAAA,OAAM;MACxDtD,EAAE,EAAEyC,KAAK,GAAG,CAAC;MACbxC,IAAI,EAAEoD,SAAS,CAACpD,IAAI;MACpB+C,OAAO,EAAE,EAAAM,oBAAA,GAAAD,SAAS,CAACR,QAAQ,CAAC,CAAC,CAAC,cAAAS,oBAAA,uBAArBA,oBAAA,CAAuBN,OAAO,KAAI,SAAS;MACpDF,MAAM,EAAEO,SAAS,CAACtC;IACpB,CAAC;EAAA,CAAC,CAAC;AACL,CAAC;;AAED;AACA,OAAO,MAAMwC,qBAAqB,GAAGA,CAAA,KAAM;EACzC;EACA,MAAMC,aAAa,GAAGjE,oBAAoB,CAAC,aAAa,EAAE,KAAK,CAAC;EAEhE,IAAI,CAACiE,aAAa,EAAE;IAClB;IACA5D,iBAAiB,CAAC,CAAC;;IAEnB;IACA,MAAM6D,aAAa,GAAG,CACpB;MAAEzD,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,mBAAmB;MAAEyD,UAAU,EAAE,CAAC,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC;MAAEC,KAAK,EAAE;QAAEC,CAAC,EAAE,GAAG;QAAEC,CAAC,EAAE,EAAE;QAAErB,CAAC,EAAE;MAAI;IAAE,CAAC,CACvH;IAED,MAAMsB,YAAY,GAAG,CACnB;MAAE9D,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,YAAY;MAAE0D,KAAK,EAAE;IAAU,CAAC,CAChD;IAED,MAAMI,eAAe,GAAG,CACtB;MAAE/D,EAAE,EAAE,CAAC;MAAEC,IAAI,EAAE,iBAAiB;MAAE+D,IAAI,EAAE;IAAa,CAAC,CACvD;IAED,MAAMC,aAAa,GAAG;MACpBrD,IAAI,EAAE,CAAC;MACPC,MAAM,EAAE,CAAC;MACTC,MAAM,EAAE;IACV,CAAC;;IAED;IACA,MAAMoD,oBAAoB,GAAG,UAAU;;IAEvC;IACA,MAAMC,mBAAmB,GAAG,EAAE;IAE9BrF,kBAAkB,CAAC,QAAQ,EAAE2E,aAAa,CAAC;IAC3C3E,kBAAkB,CAAC,OAAO,EAAEgF,YAAY,CAAC;IACzChF,kBAAkB,CAAC,UAAU,EAAEiF,eAAe,CAAC;IAC/CjF,kBAAkB,CAAC,QAAQ,EAAEmF,aAAa,CAAC;IAC3CnF,kBAAkB,CAAC,eAAe,EAAEoF,oBAAoB,CAAC;IACzDpF,kBAAkB,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1CA,kBAAkB,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACvCA,kBAAkB,CAAC,cAAc,EAAEqF,mBAAmB,CAAC,CAAC,CAAC;IACzDrF,kBAAkB,CAAC,iBAAiB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAC3DA,kBAAkB,CAAC,aAAa,EAAE,IAAI,CAAC;EACzC;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}